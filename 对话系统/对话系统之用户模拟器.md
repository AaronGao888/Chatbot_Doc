# 对话系统之用户模拟器

# 一、用户模拟器基础

## 1.1 用户模拟器产生背景
近几年来，强化学习在任务导向型对话系统中得到了广泛的应用，对话系统通常被统计建模成为一个**马尔科夫决策过程（Markov Decision Process）**模型，通过随机优化的方法来学习对话策略。
任务导向型对话系统用于帮助用户完成某个任务如查电影、找餐馆等，它一般由四个模块组成：**自然语言理解模块（Natural Language Understanding, NLU）、对话状态跟踪模块（Dialog State Tracking, DST）、对话策略模块（Dialog Policy, DP）和自然语言生成模块（Natural language Generation, NLG）**，其中 DST 和 DP 合称为**对话管理模块**。

在和用户的每轮交互过程中，对话系统利用 NLU 将用户的语句解析成为机器可理解的语义标签，并通过 DST 维护一个内部的对话状态作为整个对话历史的紧凑表示，根据此状态使用 DP 选择合适的对话动作，最后通过 NLG 将对话动作转成自然语言回复。对话系统通过和用户进行交互得到的对话数据和使用得分则可用于进行模型的强化学习训练。

然而在实际中，和真实用户的交互成本昂贵，数据回流周期慢，不足以支持模型的快速迭代，因此研究者们通常会构建一个**用户模拟器（User Simulator, US）**作为对话系统的交互环境来进行闭环训练。有了用户模拟器产生任意多的数据，对话系统可以对状态空间和动作空间进行充分地探索以寻找最优策略。

一个效果良好的用户模拟器，我们期望它**具备以下 3 个特征：**

- 有一个总体的对话目标，能够生成上下文连贯的用户动作；
- 有足够的泛化能力，在语料中未出现的对话情形里也能生成合理的行为；
- 可以给出定量的反馈评分用于指导模型学习优化。

为了实现以上目标，学术界做了大量的研究工作，从最基础的 bi-gram 模型 [4]，到经典实用的 Agenda-based的方法 [2]，再到最近基于深度学习的用户模型 [9, 10]，用户模拟器的效果得到了显著提升，也为对话模型的训练提供了有效的方法。

## 1.2 用户模拟器的基本结构
图 1 是一个比较典型的用户模拟器 [1]，对话开始时用户模拟器基于 User Goal（用户目标）发出一个话术：“Are there any action movies to see this weekend?”（这个周末有什么动作片可以看的吗?），这句话进到对话系统的自然语言理解模块和对话管理模块后，生成一句系统动作：“request_location”（询问地点）。
简便起见，这里省略掉系统的 NLG 模块，系统回复直接送到用户模拟器的用户模型（User Model），通过用户状态更新和行为策略选择，生成用户对话行为：“inform(location=San Francisco)”（告知地点为旧金山），接下来经过 Error Model（可选）和 NLG 模块，生成对应的自然语言，比如：“San Francisco, please.”（帮我订旧金山的）。以此往复，用户模拟器和对话系统持续多轮交互，直到对话结束。

![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565091242528-cd775e1a-d513-404f-8852-41657bf97a07.png#align=left&display=inline&height=532&name=image.png&originHeight=532&originWidth=1080&size=485037&status=done&width=1080)
▲ 图1. 用户模拟器（蓝色部分）和对话系统（红色部分）

从上面的过程我们可以看到，典型的用户模拟器和对话系统的结构比较相似，包含以下 4 个基本组成部分：

**1. 用户目标（User Goal）：**用户模拟的第一步就是生成一个用户对话的目标，对话系统对此是不可知的，但它需要通过多轮对话交互来帮助用户完成该目标。一般来说，用户目标的定义和两种槽位相关: 可告知槽（informable slots）和可问询槽（requestable slots），前者形如“槽=值”是用户用于查询的约束条件，后者则是用户希望向系统问询的属性。例如：用户目标是 “inform(type=movie, genre=action, location=San Francisco, date=this weekend),request(price)”表达的是用户的目标是想要找一部本周在 San Francisco 上映的动作片，找到电影后再进一步问询电影票的价格属性。有了明确的对用户目标的建模，我们就可以保证用户的回复具有一定的任务导向，而不是闲聊。

**2. 用户模型（User Model）：**用户模型对应着对话系统的对话管理模块，它的任务是根据对话历史生成当前的用户动作。用户动作是预先定义好的语义标签，例如“inform, request, greet, bye”等等。用户动作的选择应当合理且多样，能够模拟出真实用户的行为。用户模型是用户模拟器的核心组成部分，在接下来的章节里我们将会详细介绍各种具体模型和方法。

**3. 误差模型（Error Model）：**它接在 User Model 下游，负责模拟噪声，对用户行为进行扰动以模拟真实交互环境下不确定性。简单的方式有：随机用不正确的意图替换正确的意图、随机替换为不正确的槽位、随机替换为不正确的槽值等；复杂的方式有模拟基于 ASR 或 NLU 混淆的错误。

**4. 自然语言生成（NLG）：**如果用户模拟器需要输出自然语言回复，就需要 NLG 模型将用户动作转换成自然语言表述。例如用户动作标签“inform(type=movie, genre=action, date=this weekend)” 进行 NLG 模块后生成自然语句“Are there any action movies to see this weekend?”。
# 
# 
# 二、用户模拟器的实现方法

我们将用户模拟器的实现方法大致分成两类：**基于规则的方法**和**基于模型学习的方法**。我们将介绍这些方法中各自具有代表性的论文。

**2.1 基于规则的方法**

基于规则的方法需要专家手动构建，它的优点是可以冷启动，用户行为完全可控；缺点是代价大，覆盖度不够，在对话行为灵活性和多样性上比较不足，适用于话术简单清晰的填槽式对话任务。

基于规则的方法中使用最为广泛的是**基于议程（Agenda-based）的方法** [2, 3]，该方法对用户状态表示、状态转移、Agenda 更新、Goal 更新进行了精细建模，逻辑清晰，可落地性强，业界很多工作 [1, 15] 都基于该方法进行扩展和优化。
基于议程的方法通过一个栈的结构把对话的议程定下来，对话的过程就变成进栈和出栈的动作，上下文关联性很强，保证了用户动作生成的一致性，一般不会出现异常用户行为。但是，该方法在对话行为灵活性和多样性比较欠缺，在实操层面可以通过引入一些随机性提升灵活度。
**基于议程的方法**
**代表论文：**_The Hidden Agenda User Simulation Model_
_
**论文链接：**https://ieeexplore.ieee.org/document/4806280/?arnumber=4806280
_
![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565091346496-777f36d6-3624-4bbc-8203-bab84dbf4e3c.png#align=left&display=inline&height=192&name=image.png&originHeight=192&originWidth=1080&size=54763&status=done&width=1080)

首先，作者认为人机对话可以形式化为一系列状态转换和对话行为序列。在任意时刻 t  ，用户在状态 S，采取动作![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565091382616-1f7b5113-58de-494a-9688-e34df4e31c03.png#align=left&display=inline&height=30&name=image.png&originHeight=30&originWidth=40&size=4341&status=done&width=40)，过渡到中间状态 S'，收到对话系统回复的动作![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565091396040-ba84d9c6-391c-443b-8082-8a2b1d1bf708.png#align=left&display=inline&height=28&name=image.png&originHeight=28&originWidth=48&size=4537&status=done&width=48)，然后转换到下一个状态 S''，然后以此往复，循环下去。

![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565091407688-1e800e83-5c38-4457-b098-151110f81b5d.png#align=left&display=inline&height=70&name=image.png&originHeight=70&originWidth=758&size=16109&status=done&width=758)

根据马尔科夫假设，用户行为可以分解为三个模型：![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565091483234-119657c0-9e6a-4445-a63a-5e93b5cacec4.png#align=left&display=inline&height=36&name=image.png&originHeight=36&originWidth=108&size=6853&status=done&width=108)用于建模用户动作选择，![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565091497808-15d46c69-6ec3-4b1a-a91f-8e2bb50bf2f7.png#align=left&display=inline&height=38&name=image.png&originHeight=38&originWidth=138&size=7821&status=done&width=138)用于建模发出用户动作![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565091513228-4fd12168-20d4-4fa6-a258-1e698ea911bb.png#align=left&display=inline&height=30&name=image.png&originHeight=30&originWidth=40&size=4341&status=done&width=40)后用户状态转移到 S' 的概率，![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565091529657-239fb5ff-5b24-4adc-9b05-8c549407982d.png#align=left&display=inline&height=38&name=image.png&originHeight=38&originWidth=162&size=7917&status=done&width=162)用于建模接收到系统动作![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565091544562-bd9571cc-a396-42d0-ad11-d1b84b0e745d.png#align=left&display=inline&height=28&name=image.png&originHeight=28&originWidth=48&size=4537&status=done&width=48)后用户状态转移到 S'' 的概率。

用户状态 S 被分为 2 部分表示：Agenda 的内容 A 和用户目标 G。

                     ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565091562214-f0389102-4ab0-4397-ab86-a106dbdf36d5.png#align=left&display=inline&height=76&name=image.png&originHeight=76&originWidth=414&size=14165&status=done&width=414)

G 由约束条件 C 和问询内容 R 组成。在对话的过程中，G 能保证用户行为是一致的且是任务导向的。

用户 Agenda 是一个类似堆栈的结构，它存储着待执行的用户对话行为（user dialogue act）。在对话开始时，使用系统数据库随机生成新的用户目标，然后会将用户目标中所有目标约束转换为告知行为（inform acts），所有的目标问询转换为问询行为（request acts）填充到用户 Agenda。在 Agenda 的底部，会添加一个 bye act 用于结束对话。

随着对话的进行，Agenda 和 Goal 会动态更新，并从 Agenda 的顶部弹出用户对话行为以形成本轮用户动作![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565091701984-1df1261d-36fa-4e62-8a7a-e20637e3c768.png#align=left&display=inline&height=30&name=image.png&originHeight=30&originWidth=40&size=4341&status=done&width=40)。在接收到系统回复![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565091717359-c1e8741b-0ecc-40db-8ec3-634e358c884c.png#align=left&display=inline&height=28&name=image.png&originHeight=28&originWidth=48&size=4537&status=done&width=48)后，根据写好的规则新的用户动作会被压入到 Agenda 的栈顶，不相关的用户动作会被删除。当需要考虑动作的优先级时，栈顶的用户动作也可以临时被缓存起来先执行优先级高的动作，从而为模拟器提供简单的用户记忆模型。图 2 给出了用户目标和 Agenda 变化的示例。

                        ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565105561790-c3774845-44b2-4b03-9f6d-75fe14901eab.png#align=left&display=inline&height=663&name=image.png&originHeight=1326&originWidth=1005&size=584820&status=done&width=502.5)
                               ▲ 图2. 表示用户目标和agenda的状态变化的示例
用户动作选择模型![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565105592303-5599f095-d6df-47cb-bd92-eb380bd49971.png#align=left&display=inline&height=23&name=image.png&originHeight=46&originWidth=780&size=24337&status=done&width=390)，其中 δ 为狄拉克函数，A[N] 代表栈顶的元素, A[1] 代表栈底的元素, A[N-n+1..N] 代表在 Agenda 栈顶的 top-n 的用户动作 acts，该模型的直观理解是如果![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565105626733-4973e263-22bd-42c9-8a97-b68d0cbbd1ba.png#align=left&display=inline&height=15&name=image.png&originHeight=30&originWidth=40&size=4341&status=done&width=20)在 top-n 的 acts 里，那么 P 趋于 1，此时![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565105650625-e7c2231e-24f9-4aae-b8cb-da8ce5e80cb0.png#align=left&display=inline&height=15&name=image.png&originHeight=30&originWidth=40&size=4341&status=done&width=20)将会被选中并发出。top-n 的 n 的选取体现了用户模拟器的主动性程度，它可以从对话语料中统计得出，也可以根据经验指定一个小的数值。
状态更新模型![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565105669662-b5defb45-8df9-400a-b302-491e49e90590.png#align=left&display=inline&height=23&name=image.png&originHeight=46&originWidth=904&size=29011&status=done&width=452)，其中 A' 代表选择![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565105689347-b4a829cd-8ead-48f3-9a66-89d04d23ef40.png#align=left&display=inline&height=15&name=image.png&originHeight=30&originWidth=40&size=4341&status=done&width=20)后的 Agenda，N'=N-n 代表 A' 的大小，为了使 P 概率最大，则要求 A' 等于对 A 进行出栈操作后的结果 A[1..N']，G 保持不变。
已知 S=(A,G)，根据概率的链式法则和条件独立性假设，在用户模拟器接收到![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565105736486-cd8bf878-ff38-4e7e-a0fb-43ca681db1db.png#align=left&display=inline&height=14&name=image.png&originHeight=28&originWidth=48&size=4537&status=done&width=24)后，可以将状态转移模型![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565105751373-4b5127ba-e987-412d-98cb-f62b5660dfa3.png#align=left&display=inline&height=19&name=image.png&originHeight=38&originWidth=162&size=7917&status=done&width=81)分解成 Agenda 更新模型和 Goal 更新模型。
                    ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565105764652-58af519a-f500-47d8-9f7a-74ad7a063630.png#align=left&display=inline&height=43&name=image.png&originHeight=86&originWidth=984&size=32105&status=done&width=492)
如果不对 A'' 和 G'' 做限制，模型可能的状态转移空间太大，参数太多而不能直接人工指定，甚至通过大量的训练数据都不能获得一个可靠的参数估计。但如果假设 A'' 是从 A' 推导出来的，G'' 是从 G' 推导出来的，那么在每种情况下，仅需要有限个数的原子操作就能描述这个状态转移过程。

接下来，我们详细分析 Agenda 更新模型。Agenda 从 A' 转移 A'' 的过程可以看做一系列入栈操作，将用户 dialogue acts 添加到栈的顶部。接下来会进行“清理”工作，比如：删除冗余的 dialogue acts，null() acts 以及 Goal 中那些已经被填充的 request slots 关联的 request() acts。

为了简化起见，只考虑入栈操作，栈底部 1 到 N' 的元素是保持不变的，那么 Agenda 更新模型可以改写为以下公式：
                                   ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565105812316-06a91423-526e-48bf-9a28-d02eaa019aaa.png#align=left&display=inline&height=85&name=image.png&originHeight=170&originWidth=780&size=56193&status=done&width=390)
该公式表示 A'' 新增 N''-N' 个元素，而栈底元素不变。作者假设在![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565105828863-955c5032-c01b-4159-9839-5cf6d1271bf8.png#align=left&display=inline&height=14&name=image.png&originHeight=28&originWidth=48&size=4537&status=done&width=24)中的每一个系统 act 只会触发一个入栈操作，令 N''=N'+M，可得：
                       ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565105839952-d08a88ec-803b-4370-a661-cfb5c1a0d1b8.png#align=left&display=inline&height=62&name=image.png&originHeight=123&originWidth=1080&size=48643&status=done&width=540)
上式表示的是每一个系统 act 会触发一个入栈操作，同时该操作还和 Goal 有关。此时，模型已经足够简单，都可以通过编写人工规则来实现当接收到系统 act 后的逻辑，比如：当 ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565105860704-2456f704-326b-42b1-9260-cbdd904446c4.png#align=left&display=inline&height=14&name=image.png&originHeight=28&originWidth=48&size=4537&status=done&width=24)[i] 中的元素 x=y 和 G'' 里的约束条件冲突时，可以将以下任意一个用户 act 压入栈 A''：negate()，inform(x=z)，deny(x=y, x=z) 等。
Goal 更新模型![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565105882357-71aee017-1612-4b14-86b1-6f22d2f785b0.png#align=left&display=inline&height=22&name=image.png&originHeight=44&originWidth=212&size=10406&status=done&width=106)描述的是当给定![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565105926232-297ca63d-8a17-4eca-bdf7-4a14181306ce.png#align=left&display=inline&height=14&name=image.png&originHeight=28&originWidth=48&size=4537&status=done&width=24)的情形下，约束条件 C' 和问询内容是如何变化的。假定当给定 C'' 的情形下，R'' 是条件独立于 C'' 的，那么可以得到：

                                ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565105946236-cea52ff7-36e0-4974-98f4-9e203ad884a0.png#align=left&display=inline&height=45&name=image.png&originHeight=90&originWidth=1012&size=30890&status=done&width=506)

为了控制 R' 转移到 R'' 的空间大小，可以假设问询的槽位是相互独立的，并且每个槽只能利用 ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565105966793-d8988eeb-c13f-4779-844b-97177ba3e20b.png#align=left&display=inline&height=14&name=image.png&originHeight=28&originWidth=48&size=4537&status=done&width=24) 的信息来更新，或者保持不变。利用 R[k] 表示第 k 个可问询槽，M(![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565105979817-b4e51bbb-bef0-4ff0-bebe-ef8df8850805.png#align=left&display=inline&height=14&name=image.png&originHeight=28&originWidth=48&size=4537&status=done&width=24),C'') 表示 ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565105987479-03f37066-0fcd-411b-889a-dacb2717f55f.png#align=left&display=inline&height=14&name=image.png&originHeight=28&originWidth=48&size=4537&status=done&width=24) 中的槽信息与 Goal 约束条件的匹配情况。
                                  ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565105994847-893f05fd-7262-4f99-b209-1e740cd895f6.png#align=left&display=inline&height=36&name=image.png&originHeight=72&originWidth=924&size=29322&status=done&width=462)

为了简化 P(C''|![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565106006614-f6e4041a-ccea-4093-871f-a16cc1126246.png#align=left&display=inline&height=14&name=image.png&originHeight=28&originWidth=48&size=4537&status=done&width=24),R',C')，作者假设 C'' 是通过添加新约束条件，改变约束条件的槽值或者什么都不改变得到的。转移过程也不用考虑所有的情形，可以简化为只考虑 ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565106018893-fa7bc4f3-be97-4b20-8e03-05b43674a2e4.png#align=left&display=inline&height=14&name=image.png&originHeight=28&originWidth=48&size=4537&status=done&width=24) 的一些二值标识，比如：“![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565106021539-6b7f3fe3-5db9-4414-a4f9-7dd12c065f69.png#align=left&display=inline&height=14&name=image.png&originHeight=28&originWidth=48&size=4537&status=done&width=24)是否在请求约束条件的槽？”，“![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565106023951-f1b01f23-992f-4d0e-9327-2e5c2f4d8003.png#align=left&display=inline&height=14&name=image.png&originHeight=28&originWidth=48&size=4537&status=done&width=24)是否在告知没有找到满足约束条件的元素？”等。这样模型可以简化到可以通过人工编写规则实现，落地性很强。


## 2.2 基于模型学习的方法
通过人工编写规则尽管落地性强，精准率高，但是成本很高，因此寻求数据驱动的模型化方法是一个很好的途径。利用对话语料进行端到端训练的效果优于基于议程的规则方法，它的优点是数据驱动，节省人力；但缺点是复杂对话建模困难，对数据数量要求很高，因此对于一些对话语料稀缺的领域效果很差。

论文 [4] 最早提出了 bi-gram 模型，通过给定系统动作![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565106253675-de6f9e06-8726-4bb8-b90d-6d953328ee47.png#align=left&display=inline&height=17&name=image.png&originHeight=34&originWidth=36&size=4936&status=done&width=18)预测用户动作![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565106265705-2d7b1a5b-a856-4262-abb5-16fcc533ec68.png#align=left&display=inline&height=15&name=image.png&originHeight=30&originWidth=40&size=4341&status=done&width=20)，![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565106274225-f3271162-c2cd-435f-bb07-83cc08e85147.png#align=left&display=inline&height=22&name=image.png&originHeight=44&originWidth=218&size=9744&status=done&width=109), 从而对用户模型进行概率建模。尽管 bi-gram 模型简单可用，但是由于没有对整个对话历史和用户目标进行有效建模，模拟出来用户行为通常过于随机不够真实。随后提出的 Levin model [5]，Schefller model [6]， Pietquin Model [7] 均在 bi-gram 模型上进行了一定改进，使得用户动作的生成有一定的约束。
在用户模型的序列建模上，论文 [16] 利用隐马尔科夫模型来推断每一轮的用户动作。论文 [8] 则研究了基于概率图的用户模型，如图 3 所示，g 是用户目标， 分别是系统动作、用户隐动作，对话历史和用户观测动作，通过 EM 算法优化模型参数。

                                       ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565106304436-680b5344-0ae0-4b9a-b1fc-0d6cb1dd4fc5.png#align=left&display=inline&height=175&name=image.png&originHeight=350&originWidth=644&size=55927&status=done&width=322)
                                                           ▲ 图3. 用户模型的概率图建模


以上都是比较早期的统计建模方法，我们不再赘述。本文主要想从学习范式的角度对近几年涌现的一些优秀论文进行介绍，包括：
**              1、端到端有监督学习** [9, 10]
**              2、 联合策略优化** [13]
**              3、逆强化学习** [11] 
**              4、协同过滤方法** [12]

**端到端有监督学习**
**代表论文1：**_A Sequence-to-Sequence Model for User Simulation in Spoken Dialogue Systems_
_
**论文链接：**https://arxiv.org/abs/1607.00070

![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565106324190-544c1512-3cc9-4090-b4aa-2b89ca7520da.png#align=left&display=inline&height=177&name=image.png&originHeight=354&originWidth=1080&size=84826&status=done&width=540)

**之前的基于概率建模的方法往往存在着几点不足：

- 无法考虑对话历史；
- 需要刻板的结构来保证用户行为的一致性；
- 严重依赖于特定领域；
- 在一次对话期间无法输出多个用户意图。

用户模拟器的一个重要特征是它鼓励整个对话中的连贯行为，而由于之前的概率模型从易于实现的角度，基本不考虑很长的对话历史和单句多意图的情况，导致了整个对话效率比较低下。基于此作者提出了一种 **Sequence-to-sequence 的用户模拟器模型**（如图 4 所示），它将对话上下文序列![](https://cdn.nlark.com/yuque/0/2019/png/339339/1565091162593-9e3a0faf-f049-4d40-84c2-330bc333a266.png#align=left&display=inline&height=17&originHeight=42&originWidth=208&size=0&status=done&width=85)作为输入，然后输出用户动作序列![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565106815667-185ff959-1cfd-4c13-8460-9dbe7e5ec02a.png#align=left&display=inline&height=22&name=image.png&originHeight=44&originWidth=218&size=9925&status=done&width=109)。

                                  ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565106821912-867b855b-d48f-4e0e-b3bf-fbdd8c455623.png#align=left&display=inline&height=198&name=image.png&originHeight=396&originWidth=616&size=61326&status=done&width=308)
                                                         ▲ 图4. 用户模拟器端到端模型
在每次对话开始之前，统一的构建出一个 Goal G=(C,R)，对于餐馆查询任务而言，约束条件通常指的是菜品口味、菜品价格以及餐馆所在方位，问询内容为以下槽位：餐馆名称、餐馆地址、餐馆电话等。


**在第 t 轮对话，一个上下文**![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565106855377-0bb62c29-ed1c-483f-a327-e332fbe7a788.png#align=left&display=inline&height=16&name=image.png&originHeight=32&originWidth=32&size=4447&status=done&width=16)**包含以下 4 部分**：


1）上一轮的系统动作![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565107011551-77d8a9df-e995-44d2-ba1c-7b5da1a57241.png#align=left&display=inline&height=19&name=image.png&originHeight=38&originWidth=70&size=5724&status=done&width=35)；
2）上一轮系统回复的信息与 User Goal 不一致的部分![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565107022609-7170f58c-b8e5-4ed7-b48d-f34c45186f18.png#align=left&display=inline&height=21&name=image.png&originHeight=42&originWidth=168&size=9489&status=done&width=84)；
3）约束条件的状态![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565107031656-d70b60d2-a779-4dba-82eb-2439a8052ca8.png#align=left&display=inline&height=18&name=image.png&originHeight=36&originWidth=104&size=7212&status=done&width=52)（告知与否）；
4）问询内容的状态![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565107040560-df5589ee-53f1-482e-a348-b69d3481957e.png#align=left&display=inline&height=17&name=image.png&originHeight=34&originWidth=70&size=5991&status=done&width=35)（被告知与否）。
在每次对话的过程中，会根据 dialogue acts 的个数以及 Goal 的状态，对以上 4 部分进行 one-hot 编码，从而得到对话上下文的向量化表示。如下表所示：

            ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565107068595-939fa0c0-492a-4359-a448-fe84619b1808.png#align=left&display=inline&height=230&name=image.png&originHeight=459&originWidth=1080&size=276999&status=done&width=540)


在 t 时刻，将上下文序列![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565107082207-ad9aa62b-aa37-41c3-9b28-69c67862bd82.png#align=left&display=inline&height=16&name=image.png&originHeight=32&originWidth=32&size=4447&status=done&width=16)输入到一个 encoder LSTM 网络，得到一个向量![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565107092195-8fd4ccca-13bb-49c8-8a86-b617d0c6e2d0.png#align=left&display=inline&height=17&name=image.png&originHeight=34&originWidth=36&size=4556&status=done&width=18)作为对话历史的内部表示。其中，![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565107104956-d5632053-e458-4071-aa3b-599ff7e256f1.png#align=left&display=inline&height=20&name=image.png&originHeight=40&originWidth=586&size=23173&status=done&width=293)，⊙ 代表拼接操作。

然后再将向量![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565107116672-87566184-4f39-433b-b099-be8e7ad6809f.png#align=left&display=inline&height=17&name=image.png&originHeight=34&originWidth=36&size=4556&status=done&width=18)输入到 decoder LSTM 网络，输出 dialogue acts 序列，比如 (inform, request)。接下来需要通过启发式规则将 dialogue acts 映射为带槽的用户行为，比如 inform(food=Chinese), request(price_range)。作者也提到可以训练一个模型，让它直接输出最终的行为，比如 request_area，inform_pricerange。这种方式的优点是不需要写启发式规则，可以做到更细粒度的建模，这也是作者推荐的方式。最后实验结果证明效果优于基于议程的方法。

![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565107132905-6462da1e-513b-41f4-807b-97da23cd92d8.png#align=left&display=inline&height=87&name=image.png&originHeight=174&originWidth=1080&size=52301&status=done&width=540)
**代表论文2：**_Neural User Simulation for Corpus-based Policy Optimization for Spoken Dialogue Systems_
**论文链接：**https://aclweb.org/anthology/papers/W/W18/W18-5007/

![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565107141919-b50c0db9-57c2-4f4e-91cf-a1ed41102549.png#align=left&display=inline&height=201&name=image.png&originHeight=402&originWidth=1080&size=153867&status=done&width=540)

上一篇论文中的一些端到端系统虽然对整个对话历史都进行了跟踪，并且用户的行为是从数据中学习得到的，但是依旧存在两个问题：1）没有对用户的目标改变（goal change）进行建模；2）只在语义层面进行用户模拟，需要耗费人力标注出每轮用户语句的语义标签进行模型训练，而不是直接利用自然语句进行训练。

因此该论文提出了**基于 RNN 的 Neural User Simulator (NUS) 模型**。首先 NUS 通过用户目标生成器，对原对话数据中的对话状态标签进行预处理，得到一个完整对话中每一轮的具体用户目标，这样就相当于对用户目标改变进行了某种程度上的建模，如下表所示：

                        ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565107162184-3b668975-6a3f-4f02-896f-48ea7f6d9d89.png#align=left&display=inline&height=87&name=image.png&originHeight=174&originWidth=1080&size=105722&status=done&width=540)

 表中显示某个对话一共有四轮，其中 第 2、3 轮之间出现了对 food 这个槽位的 goal change, 因此右边处理之后得到了用户目标也出现了变化。这样的用户目标不再是一成不变，而是充分根据对话数据给出了动态的用户目标，更加贴近实际。
有了每轮的用户目标，NUS 通过 RNN 来生成用户语句, 如图 5 所示：
                   ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565107333742-6b212965-cca9-45fe-8db8-4721ad170ef1.png#align=left&display=inline&height=167&name=image.png&originHeight=333&originWidth=1080&size=86037&status=done&width=540)
                                         ▲ 图5. 神经用户模拟器的端到端模型


图中![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091162824-17a00c32-6f11-4e88-a8c0-d81246f8f971.webp#align=left&display=inline&height=14&originHeight=34&originWidth=36&size=0&status=done&width=15)是每一轮提取出来的特征，它一共包含四个向量![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091163955-96b7cb30-04db-4501-aa29-a81bc2178541.webp#align=left&display=inline&height=20&originHeight=44&originWidth=310&size=0&status=done&width=140)：其中![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091162588-3658d3d2-e896-4157-ae5e-4b9e568fc888.webp#align=left&display=inline&height=13&originHeight=32&originWidth=38&size=0&status=done&width=15)是系统动作向量，包含![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091162314-10cf33db-892c-4fab-8430-94ca17b90ac5.webp#align=left&display=inline&height=17&originHeight=46&originWidth=212&size=0&status=done&width=80)，![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091164175-676604c9-700d-4fbd-b135-714239ed9051.webp#align=left&display=inline&height=17&originHeight=44&originWidth=42&size=0&status=done&width=16)是一个长度等于所有可能的系统动作的二进制向量，![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091164175-9c8c5fac-8fa8-447b-8295-61a120eb5a5d.webp#align=left&display=inline&height=16&originHeight=42&originWidth=42&size=0&status=done&width=16)是一个长度为可告知槽（informable slots）总个数 4 倍的二进制向量，用来表示本轮系统动作是否出现了 request、select、inform 和 expl-conf 这四个以可告知槽为参数的动作。
例如出现了 request(area) 则将![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091162553-2324b578-9fb0-4cfa-95c5-f181856914a1.webp#align=left&display=inline&height=16&originHeight=42&originWidth=42&size=0&status=done&width=16)中对应位置处元素置 1；![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091164442-00fb2bb1-b21c-44ce-8cb5-1192538c3e16.webp#align=left&display=inline&height=14&originHeight=34&originWidth=30&size=0&status=done&width=12)称作问询向量，是一个长度和可问询槽（requestable slots）总个数相等的二进制向量，用来标记哪些用户目标中需要问询的可问询槽还没有被用户向系统提问；![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091162547-f117d2d9-4eb0-4589-9352-853204ba87fd.webp#align=left&display=inline&height=16&originHeight=40&originWidth=30&size=0&status=done&width=12)称作不一致向量（inconsistency vector）,  长度等于可告知槽总个数，一旦系统动作中对某个槽出现了和本轮用户目标不一致的情况，对应的位置处元素置 1。![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091164237-65cb7342-f68b-4792-a6ea-8d0d2db54452.webp#align=left&display=inline&height=15&originHeight=32&originWidth=32&size=0&status=done&width=15)是用户目标约束向量，长度等于可告知槽总个数，用来表示本轮用户目标中出现了哪些可告知槽。
NUS 生成的回复是去词汇化的自然语句，经过后处理则得到了用户的自然语言回复。论文为了论证 NUS 效果优异 Agenda-based User Simulator (ABUS)， 提出了一个交叉模型评估的方法，即在一个 User Simulator 上训练一个 agent，在其他 User Simulator 上测试该 agent，如果 agent 效果依旧很好，说明用于训练的 User Simulator 是更加贴近真实用户。
最终实验结果证明，在 NUS 上训练得到了的 agent，在 ABUS 和真实用户上测试得到的成功率均优于 ABUS，而在 ABUS 上训练得到的 agent 效果只在 ABUS 上测试好。

**联合优化策略**

**代表论文：**_Iterative Policy Learning in End-to-End Trainable Task-Oriented Neural Dialog Models_

**论文链接：**https://arxiv.org/abs/1709.06136v1

![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565608204154-41c72616-a061-466d-9529-b8dd3c65cf01.png#align=left&display=inline&height=198&name=image.png&originHeight=396&originWidth=1080&size=149273&status=done&width=540)

用户模型和对话管理模型功能十分接近，因此对用户模型也采用强化学习的框架，将用户模拟器和对话系统联合优化是一个可行的方向。论文在**对用户模拟器和对话系统分别采用了 RNN 进行端到端的建模并使用同一个回报函数优化，两者交替训练共同最大化累计回报。**

论文使用的对话系统是一个端到端的 LSTM 模型，如图 6 所示：

                                    ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565608235444-08c8f168-2439-4ff6-b249-a08e6ddf3796.png#align=left&display=inline&height=280&name=image.png&originHeight=559&originWidth=674&size=248334&status=done&width=337)
                                                       ▲ 图6. 对话系统网络结构

对话系统的状态由 LSTM 的隐层节点编码，每一轮都会进行更新。在第 k 轮对话，给定上一轮的系统语句 ![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091164146-23b7e7bb-4e95-4fa6-8636-7655be9fa1b2.webp#align=left&display=inline&height=17&originHeight=70&originWidth=94&size=0&status=done&width=23) ，用户语句 ![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091164098-a7c08fca-09e9-47e3-8119-f8c75929425c.webp#align=left&display=inline&height=19&originHeight=76&originWidth=94&size=0&status=done&width=23) ，数据库查询结果 ![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091162902-d12dd225-8b8d-4784-a860-3f9d5b4bc59c.webp#align=left&display=inline&height=18&originHeight=66&originWidth=86&size=0&status=done&width=23) 作为输入，LSTM 模型更新上一轮的对话状态 ![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091164096-7177aaf1-e7d7-4685-9d45-e8018f6c201e.webp#align=left&display=inline&height=17&originHeight=66&originWidth=92&size=0&status=done&width=23) 为 ![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091163381-889377de-b5fe-421b-89a0-d9d634d19332.webp#align=left&display=inline&height=17&originHeight=64&originWidth=56&size=0&status=done&width=15)。新的对话状态 ![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091163902-e1a25525-4c52-4e94-b543-f042502d9def.webp#align=left&display=inline&height=17&originHeight=64&originWidth=56&size=0&status=done&width=15) 通过前馈神经网络可以直接预测出本轮各个槽的跟踪分布、系统应采取的对话动作 ![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091161808-c24d3d03-44b6-4806-b5d7-e525945f1d71.webp#align=left&display=inline&height=20&originHeight=74&originWidth=64&size=0&status=done&width=17) 和一个 one-hot 编码的数据库指针 。NLG 部分作者选择采用模板的方法生成。

对应的用户模拟器的结构如图 7 所示。它也是采用了端到端的 LSTM 模型，输入换作了用户目标编码 ![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091163426-8763937d-73ed-4ad5-a560-bfe0abc81ca6.webp#align=left&display=inline&height=16&originHeight=66&originWidth=66&size=0&status=done&width=16)，上一轮用户语句 ![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091162774-b92b7abf-57f6-49e0-8999-988bd4142914.webp#align=left&display=inline&height=19&originHeight=76&originWidth=94&size=0&status=done&width=23) 和当前轮系统语句 ![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091164381-295d334e-22bf-48bf-b0ae-143d970f68cc.webp#align=left&display=inline&height=18&originHeight=52&originWidth=52&size=0&status=done&width=18)，模型每轮更新用户状态 ![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091162749-6399cf12-6178-4f9c-bb9d-ddb9b9b3bab3.webp#align=left&display=inline&height=17&originHeight=56&originWidth=76&size=0&status=done&width=23) 为 ![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091163638-de409eea-3bc6-4115-8767-5a7fe43024b2.webp#align=left&display=inline&height=18&originHeight=56&originWidth=46&size=0&status=done&width=15)。新的用户状态 ![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091163974-6a3d5434-f249-4a46-b52c-6da555c06b08.webp#align=left&display=inline&height=18&originHeight=56&originWidth=46&size=0&status=done&width=15) 也通过前馈神经网络得到本轮用户应采取的动作和槽值参数。NLG 部分采用模板的方法直接生成。

                               ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565608275396-966cb85e-7765-4d09-8a42-ac01dc8cd0ee.png#align=left&display=inline&height=286&name=image.png&originHeight=571&originWidth=566&size=158837&status=done&width=283)
                                             ▲ 图7. 用户模拟器网络结构


作者对用户模拟器和对话系统进行联合策略优化，使用了策略梯度（policy gradient）算法，两者各自的状态为  ![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091163346-c4f150ce-8e35-49da-82be-522c8711cf1a.webp#align=left&display=inline&height=17&originHeight=64&originWidth=56&size=0&status=done&width=15) 和 ![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091163942-9b84ed88-13fa-4b64-a00d-15156df69bd7.webp#align=left&display=inline&height=18&originHeight=56&originWidth=46&size=0&status=done&width=15)，动作为 ![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091163294-2c0b8cc4-f6d5-4db9-91f2-a234a78d7112.webp#align=left&display=inline&height=21&originHeight=74&originWidth=64&size=0&status=done&width=18)和 ![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091163143-162820e6-e0e2-40b9-88dd-4b79abdb0ad9.webp#align=left&display=inline&height=22&originHeight=64&originWidth=44&size=0&status=done&width=15)。回报函数采用：         ![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091163740-af7676cf-e92d-4c94-b210-0d4107ca4642.webp#align=left&display=inline&height=54&originHeight=132&originWidth=616&size=0&status=done&width=251)
![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091163927-97a19699-a491-4012-91f8-c803f26e43de.webp#align=left&display=inline&height=16&originHeight=66&originWidth=66&size=0&status=done&width=16) 是用户目标，![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091163958-66989590-8e4c-430f-b52e-b0dc6e5990ea.webp#align=left&display=inline&height=17&originHeight=52&originWidth=48&size=0&status=done&width=16) 是对话系统对用户目标的估计，D( · ) 是一个得分函数。根据相邻轮得分函数之差可以得到单轮回报函数![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091163676-cb82d951-8848-48bf-840b-76ee81048eaa.webp#align=left&display=inline&height=15&originHeight=34&originWidth=35&size=0&status=done&width=15)。用户模拟器和对话系统交替优化，共同最大化累计回报函数![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091164449-44e796e6-860a-44e4-a189-4ab55c6a5fdc.webp#align=left&display=inline&height=14&originHeight=38&originWidth=41&size=0&status=done&width=15)。
![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565608306711-53242401-408d-42a5-87bb-6b4239605e42.png#align=left&display=inline&height=57&name=image.png&originHeight=113&originWidth=1080&size=81357&status=done&width=540)
为了降低 REINFORCE 策略梯度优化的方差，论文采用 Advantage Actor-Critic (A2C) 算法，并使用 ε-softmax 进行策略探索，在 DSTC2 数据集上进行了初步实验，结果如下：


                        ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565608331922-ea5c99d5-a5c6-44d2-a0b6-3bfd62e7d46c.png#align=left&display=inline&height=125&name=image.png&originHeight=249&originWidth=673&size=68285&status=done&width=336.5)

**逆强化学习** 

**代表论文：**_User Simulation in Dialogue Systems using Inverse Reinforcement Learning_
_
**论文链接：**https://core.ac.uk/download/pdf/52801075.pdf

![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565608341952-e3d669e8-4c77-4a5f-868e-73ae80cfefc0.png#align=left&display=inline&height=168&name=image.png&originHeight=335&originWidth=1080&size=138261&status=done&width=540)

在马尔科夫决策过程  (MDP)  的框架下, 强化学习在是回报函数（reward function）给定下，找出最优策略以最大化累计反馈，而逆强化学习（Inverse reinforcement learning, IRL）就是通过给出最优策略估计出回报函数。
通常最优策略会通过专家行为近似得到，例如请经验丰富的专家充当用户直接给出合理的回复。需要注意的是模仿学习（imitation learning）和 IRL 不同，模仿学习是直接通过专家行为的数据优化策略而不估计回报函数。

目前很多基于强化学习的对话管理模块中，回报函数多以是否成功和总轮数给出，不够多样真实，IRL 方法对于优化回报函数也有很大的潜力，值得研究。

论文给出了 UserMDP，对用户模拟器也进行 MDP 建模，利用 IRL 估计出回报函数，从而为 User simulator 和 Agent 交替使用强化学习优化提供有效途径。

首先论文假设回报函数是状态动作特征基函数的线性拟合：

![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091164079-b7505b9d-bcca-4b22-98e7-c1281fc7a5f0.webp#align=left&display=inline&height=27&originHeight=60&originWidth=668&size=0&status=done&width=297)


Q function 则可以表示成：
                                     ![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091163340-f82392fd-d25f-4015-802e-fdcd133e0234.webp#align=left&display=inline&height=38&originHeight=108&originWidth=1060&size=0&status=done&width=372) 
![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565658124494-a9f4147c-1c0e-405b-8064-11f20ca65fa3.png#align=left&display=inline&height=22&name=image.png&originHeight=44&originWidth=130&size=7692&status=done&width=65)被称作特征期望（feature expectation），实际中通过采样统计得到，设采样了 m 个 episode 序列样本，第 i 个序列的长度记为 Hi。

                              ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565658150528-4bbf9484-2714-451b-a4a9-236bded5600f.png#align=left&display=inline&height=60&name=image.png&originHeight=120&originWidth=622&size=27235&status=done&width=311)
具体的 IRL 算法如下：
                                ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565658177983-e2662cae-ad33-4622-ac2d-437675a75f05.png#align=left&display=inline&height=227&name=image.png&originHeight=454&originWidth=661&size=135342&status=done&width=330.5)
![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565658348226-270ece2e-7e97-4084-ac4b-79c5283e56c8.png#align=left&display=inline&height=20&name=image.png&originHeight=40&originWidth=114&size=6835&status=done&width=57)首先通过对话语料收集出真实的用户对话策略的特征期望 , 并且初始化用户模拟器的对话策略![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091164400-43e06128-792c-4f6f-8553-a9de44f697f0.webp#align=left&display=inline&height=15&originHeight=40&originWidth=124&size=0&status=done&width=45)，通过采样得到模拟用户的特征期望![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565658365606-9fc91e93-493f-4c5e-9ae8-8c9a4fbdc8fe.png#align=left&display=inline&height=20&name=image.png&originHeight=40&originWidth=114&size=6835&status=done&width=57)，![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091163788-65b9e335-bd52-4c5c-93ab-919689a1147b.webp#align=left&display=inline&height=15&originHeight=40&originWidth=124&size=0&status=done&width=45)添加到对话策略集合 Π 中; 然后经过多次迭代，每次根据估计出的回报函数进一步求解出新的最优对话策略![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565658394537-88b3c806-541d-4bb4-9a86-59645fcb68f2.png#align=left&display=inline&height=20&name=image.png&originHeight=40&originWidth=124&size=6941&status=done&width=62)并添加到策略集合 Π 中。算法最终可以合理估计出回报函数的，该回报函数和专家策略![](https://cdn.nlark.com/yuque/0/2019/webp/339339/1565091164181-0918ae5e-38f2-40c7-9c9b-b910d37624e9.webp#align=left&display=inline&height=15&originHeight=40&originWidth=124&size=0&status=done&width=45)相容。

论文中实验结果表明，通过对 IRL 找出来的策略集合 Π 进行加权随机采样得到的用户对话策略相比于固定的用户策略（专家行为）有更短的对话轮数和更高的 reward 值。说明了 IRL 方法在估计出回报函数的同时也能得到更加多样真实的策略，这在某些场景下将会非常有用。


                 ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565658416967-1288a8cc-4540-488b-b28d-df4af2a3be9d.png#align=left&display=inline&height=55&name=image.png&originHeight=110&originWidth=1080&size=39995&status=done&width=540)


**协同过滤方法**

**代表论文：**_Collaboration-based User Simulation for Goal-oriented Dialog Systems_
_
**论文链接：**http://www.alborz-geramifard.com/workshops/nips17-Conversational-AI/Papers/17nipsw-cai-collaboration-based-simulator.pdf

![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565658437146-a094abdc-3b89-428e-84c8-fda3a3031fd4.png#align=left&display=inline&height=218&name=image.png&originHeight=435&originWidth=1080&size=107039&status=done&width=540)

在有高质量语料库的情况下，我们可以考虑直接根据对话上下文，从语料库中推荐出最恰当的用户语句作为用户模拟器的回复。Amazon  的论文就是根据这样的想法设计了基于协同过滤算法的用户模拟器。首先，论文论证了在客服领域，对话系统的语句表达相比于用户的表达通常比较规整单一，因此可以对所有的用户语句进行粗略的标注，如图 8 所示：

                     ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565658475613-9ff21357-db5a-458d-9f46-c19d8fede30f.png#align=left&display=inline&height=276&name=image.png&originHeight=552&originWidth=1080&size=279765&status=done&width=540)
▲ 图8. (a) 每个对话被转换成语义标签序列 (b) 正在进行的对话和语料库对话的匹配示意图，红橙色表示系统标签，绿色表示用户语句

系统语句被赋予了 salutation、apology 等等语义标签，这样语料库中的对话都被抽象成了一个个语义标签序列，每次进行用户语句推荐时，通过计算正在进行的对话所对应的语义标签序列和语料库中每个对话对应的语义标签序列的编辑距离进行粗筛，得到本轮用户语句回复的候选集，再对候选集中各个用户语句所在对话的上一轮系统语句的 tf-idf 特征排序进行 re-rank，从而选择最佳用户语句回复。
**具体的算法如下：**


- 能够衡量生成的对话动作的一致性；
- 评价方式和具体的任务无关；
- 可以从目标信息中自动化地计算出一个标量值，而无需人工干预。

                                            ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565658566053-211ffbf4-491b-4b3f-a2f8-610558c09b8c.png#align=left&display=inline&height=296&name=image.png&originHeight=591&originWidth=782&size=258309&status=done&width=391) 
论文实验结果显示，由协同过滤的方法所给出的用户语句在众包平台上评估得到的可行率为 84.7%。

# 
# 三、用户模拟器的评价方式

论文 [14] 提出，**一个好的用户模拟器的评价方式需要满足以下几点要求：**
**

- 能够衡量生成的对话动作的一致性；
- 评价方式和具体的任务无关；
- 可以从目标信息中自动化地计算出一个标量值，而无需人工干预。

通常用户模拟器的评价指标可以分为**单轮级别度量 (turn-level metrics) **和**对话级别度量 (dialog-level metrics)**。
单轮级别度量主要针对用户动作的语义标签，最常见度量是精确率，召回率和 F1 得分，对于每一轮可以计算：
                   ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565658615557-50f56980-955a-491f-a001-fc4b89b95643.png#align=left&display=inline&height=251&name=image.png&originHeight=502&originWidth=1080&size=158450&status=done&width=540)
但是以上的度量不能评估用户模型泛化能力，例如某个用户动作是合理的但因为在对话数据中并未出现，如果预测了就会导致得分低。因此我们还可以将用户动作的预测概率分布P和真实概率分布 Q 之间的 KL 距离作为度量，从概率分布上评估用户预测模型的合理性。

                                              ![image.png](https://cdn.nlark.com/yuque/0/2019/png/339339/1565658629939-27ad4866-9575-4a7c-8c7a-f0fbd0c46058.png#align=left&display=inline&height=90&name=image.png&originHeight=180&originWidth=544&size=25411&status=done&width=272)

类似地，也可以用过计算对数似然值或者混淆度（perplexity）来评估。

对话级别的度量最常用的是**任务完成率**和**平均对话轮数**。将用户模型和对话系统进行真实交互，完成训练后的对话系统所能达到的任务完成率（通过记录对话系统是否完成用户目标得到）和平均每个对话的轮数可以作为评价与用户模型整体效果的有效指标。
# 
# 四、用户模拟器面临的挑战

**1. 对话行为一致性（Coherence）：**对话行为要保证前后连贯，符合语境，避免出现不符合逻辑的对话行为。如何综合考虑对话上下文和 User Goal 等因素，保证用户行为序列在多轮交互过程中的一致性是一个有挑战的课题。

**2. 对话行为多样性（Diversity）：**模拟用户群的行为特性，需要建模这个群体的行为分布。例如某用户群是健谈的还是寡言的，是犹豫的还是果断的，各部分占比多少，这里引入用户群体画像特征，使得用户模拟器的行为更加丰富多样，贴近目标用户群体。这个方向学术界有一些研究进展，值得继续深入研究。

**3. 对话行为的泛化性（Generalization）：**目前来看，无论是基于规则方法还是基于模型学习的用户模拟器，在遇到语料中未曾出现的对话上下文时，表现出的泛化能力依旧比较有限。对话行为的泛化性直接体现了用户模拟器是否表现得如同真实用户一样处理更多未见的复杂的对话场景。这个方向有待学界更深入的探索。

# 
# 五、总结

用户模拟器是对话系统形成闭环训练的重要组成部分，它和对话系统结构类似，但最大的区别在于增加了用户目标的建模。好的用户模拟器不仅能够生成连贯的动作，而且还能够体现多样性和泛化能力。
本综述详细地介绍了目前学界的常用模型和方法**。**由于学界一般关注的对话任务是订餐馆、订电影票、订飞机票这类简单的填槽（slot-filling）任务，对话的状态和动作空间有限，不需要太复杂的模型和大规模的语料就能获得比较好的效果，因此在数据充分的情况下，基于模型学习的方法在效果上普遍优于基于规则的方法。
而在工业界真实的场景里，除了上面的简单任务，占比更多的是“查话费”、“开发票”、“挂失信用卡”这类中等复杂度的场景，它的特点是机器人有外部 API 调用、基于 API 返回结果的分支判断、异常兜底逻辑、多个子意图的串联、多个填槽过程等，对话的状态和动作空间迅速扩大，需要有足量的训练语料才能保证用户模拟器的覆盖率。
因此在实际生产实践中，我们需要划分好场景，重新制定更加贴近业务的用户动作标签，统计出真实的用户目标，再选择最合适自身场景的模型来构建模拟器。

# 参考文献

[1] Li X, Chen Y N, Li L, et al. End-to-end task-completion neural dialogue systems[J]. arXiv preprint arXiv:1703.01008, 2017.
[2] Schatzmann J, Young S. The hidden agenda user simulation model[J]. IEEE transactions on audio, speech, and language processing, 2009, 17(4): 733-747.
[3] Schatzmann J, Thomson B, Weilhammer K, et al. Agenda-based user simulation for bootstrapping a POMDP dialogue system[C]//Human Language Technologies 2007: The Conference of the North American Chapter of the Association for Computational Linguistics; Companion Volume, Short Papers. Association for Computational Linguistics, 2007: 149-152.
[4]W. Eckert, E. Levin, and R. Pieraccini. 1997. User modelling for spoken dialogue system evaluation. In Proc. of ASRU ’97, pages 80–87.
[5]E. Levin, R. Pieraccini, and W. Eckert, “A stochastic model of human machine interaction for learning dialog strategies,” IEEE Trans. Speech Audio Process., vol. 8, no. 1, pp. 11–23, Jan. 2000.
[6]K. Scheffler and S. J. Young. 2001. Corpus-based dialogue simulation for automatic strategy learning and evaluation. In Proc. NAACL Workshop on Adaptation in Dialogue Systems, pages 64–70.
[7]O. Pietquin. 2004. A Framework for Unsupervised Learning of Dialogue Strategies. Ph.D. thesis, Faculte Polytechnique de Mons.
[8] Lee S, Eskenazi M. An unsupervised approach to user simulation: toward self-improving dialog systems[C]//Proceedings of the 13th Annual Meeting of the Special Interest Group on Discourse and Dialogue. Association for Computational Linguistics, 2012: 50-59.
[9] Layla El Asri, Jing He, and Kaheer Suleman. 2016. A sequence-to-sequence model for user simulation in spoken dialogue systems. Proceedings of the 17th Annual Conference of the International Speech Communication Association, pages 1151–1155
[10] Kreyssig F, Casanueva I, Budzianowski P, et al. Neural user simulation for corpus-based policy optimisation for spoken dialogue systems[J]. SIGDIAL, 2018.
[11] Chandramohan S, Geist M, Lefevre F, et al. User simulation in dialogue systems using inverse reinforcement learning[C]//Interspeech 2011. 2011: 1025-1028.
[12] Devin Didericksen，Oleg Rokhlenko, Kevin Small, Li Zhou, Jared Kramer. Collaboration-based User Simulation for Goal-oriented Dialog Systems. NIPS 2017
[13] Liu B, Lane I. Iterative policy learning in end-to-end trainable task-oriented neural dialog models[C]//2017 IEEE Automatic Speech Recognition and Understanding Workshop (ASRU). IEEE, 2017: 482-489.
[14] Pietquin O, Hastie H. A survey on metrics for the evaluation of user simulations[J]. The knowledge engineering review, 2013, 28(1): 59-73.
[15] Shah P, Hakkani-Tür D, Tür G, et al. Building a conversational agent overnight with dialogue self-play[J]. NAACL, 2018.
[16] H. Cuayahuitl, S. Renals, O. Lemon, and H. Shimodaira, “Human computer dialogue simulation using hidden Markov models,” in Proc. ASRU, San Juan, Puerto Rico, 2005



